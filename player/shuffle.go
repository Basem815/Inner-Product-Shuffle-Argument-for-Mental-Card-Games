package player

import (
	"crypto/rand"
	"fmt"
	"main/preprocessing"
	"math/big"
	mrand "math/rand"
)

type Player struct {
	Id	int 
	secretKey *big.Int 
	PublicKey *big.Int
	KeyPair Proof 
	Secret_s           *big.Int 	// Used during the shuffle
	
}
func (player Player) GetSecretKey() (*big.Int) {
    return player.secretKey
}

// generates a permutation of n elements
func (player Player) GeneratePermutation (n []int) ([]int){
	mrand.Shuffle(len(n), func(i, j int) {
        n[i], n[j] = n[j], n[i]
    })
	return n
}
func (player Player) GenerateNRandVals(pp preprocessing.PublicParameters, n int) []*big.Int{
	sliceS := []*big.Int{}
	outer:
	for len(sliceS) < n {
		s := player.GenerateRandValue(pp)
		for _, x := range sliceS{
			if x.Cmp(s) == 0 {
				continue outer
			}
		}
		sliceS = append(sliceS, s)
	}
	return sliceS
}
func (player Player) GenerateRandValue(pp preprocessing.PublicParameters) *big.Int {
	s, _ := rand.Int(rand.Reader, new(big.Int).Sub(pp.GetPrimeQ(), big.NewInt(1))) 
	s.Add(s, big.NewInt(1))
	return s		// s ranges from [1, p-1]
}

// Generates a single random value which is a product of all values generated by set of players
func CombinedChallenge(pp preprocessing.PublicParameters, otherPlayers []Player) *big.Int {
	combinedRandVal := big.NewInt(1)
	for _, player := range otherPlayers{ 
		combinedRandVal.Mul(combinedRandVal, player.GenerateRandValue(pp))
		combinedRandVal.Mod(combinedRandVal, pp.GetPrimeQ())
	}
	return combinedRandVal
}

func (player *Player) Shuffle(pp preprocessing.PublicParameters, 
	cipherTexts [][2]*big.Int) (Prover, *big.Int, [][2]*big.Int){
	
	fmt.Printf("Beginning of Shuffle operation by player %v \n", player.Id)
	p := pp.GetPrimeP()
	g := pp.GetGeneratorG()
	g_prime := new(big.Int)
	s := new(big.Int)
	for {
		s = player.GenerateRandValue(pp)
		g_prime = new(big.Int).Exp(g, s, p)
		if isGenerator(pp, g_prime) {
			break
		}
	}
	cards := make([]int, len(cipherTexts))
	for i := 0; i < len(cipherTexts); i++ {
        cards[i] = i + 1
    }
	permutation := player.GeneratePermutation(cards)
	new_cipherTexts := [][2]*big.Int{}
	// Permute the original list and raise each component to the power of the secret value
	for i := range cipherTexts {
		new_cipherTexts = append(new_cipherTexts, ReEncrypt(pp, cipherTexts[permutation[i]-1], s))
	}
	sigma_v := player.GenerateRandValue(pp)
	sigma_w := player.GenerateRandValue(pp)
	player.Secret_s = s 
	prover := Prover{
		Player: *player,
		Secret_permutation: permutation,
		Sigma_v: sigma_v,
		Sigma_w: sigma_w,
	}
	fmt.Printf("Player with id %v successfully performed the shuffle operation \n", prover.Id)
	return prover, g_prime, new_cipherTexts
}